ll powll(ll n, ll p) {
  if (p == 0) return 1;
  else if (p == 1) return n;
  else {
    ll ans = powll(n, p / 2);
    ans = ans * ans;
    if (p % 2 == 1) ans = ans * n;
    return ans;
  }
}

// n = 1.5e7 -> 80 ms
vll list_prime_until(ll n) {
	vll ret;
	vector<bool> is_prime(n + 1, true);
	if (is_prime.size() > 0) is_prime[0] = false;
	if (is_prime.size() > 1) is_prime[1] = false;
	Loop(i, n + 1) {
		if (is_prime[i]) {
			ret.push_back(i);
			ll k = (ll)i * i;
			while (k < n + 1) {
				is_prime[int(k)] = false;
				k += i;
			}
		}
	}
	return ret;
}

// prime_list has to be generated by list_prime_until(>=sqrt(n))
vector<Pll> prime_factorize(ll n, const vll &primes) {
  vector<Pll> ret;
  Loop(i, primes.size()) {
    if (n == 1) break;
    while (n % primes[i] == 0) {
      if (ret.size() == 0 || ret.back().fst != primes[i]) {
        ret.push_back({ primes[i], 0 });
      }
      ret.back().snd++;
      n /= primes[i];
    }
  }
  if (n != 1) ret.push_back({ n, 1 });
  return ret;
}

vll divisors(const vector<Pll> factors) {
	queue<ll> que;
	que.push(1);
	Loop(i, factors.size()) {
		ll x = factors[i].fst, d = factors[i].snd;
		vll a(d + 1, 1); Loop1(j, d) a[j] = a[j - 1] * x;
		int m = int(que.size());
		Loop(j, m) {
			ll y = que.front(); que.pop();
			Loop(k, d + 1) que.push(y * a[k]);
		}
	}
	int m = int(que.size());
	vll ret(m);
	Loop(i, m) {
		ret[i] = que.front(); que.pop();
	}
	sort(ret.begin(), ret.end());
	return ret;
}

pair<vector<Pll>, vector<Pll>> reduce_common_factors(const vector<Pll> &x_factors, const vector<Pll> &y_factors) {
	pair<vector<Pll>, vector<Pll>> ret;
	int n = int(x_factors.size()), m = int(y_factors.size());
	int i = 0, j = 0;
	while (i < n && j < m) {
		if (x_factors[i].fst < y_factors[j].fst) ret.fst.push_back(x_factors[i++]);
		else if (x_factors[i].fst > y_factors[j].fst) ret.snd.push_back(y_factors[j++]);
		else {
			ll cnt = min(x_factors[i].snd, y_factors[i].snd);
			if (x_factors[i].snd - cnt > 0) ret.fst.push_back({ x_factors[i].fst, x_factors[i].snd - cnt });
			if (y_factors[j].snd - cnt > 0) ret.snd.push_back({ y_factors[j].fst, y_factors[j].snd - cnt });
			++i; ++j;
		}
	}
	while (i < n) ret.fst.push_back(x_factors[i++]);
	while (j < m) ret.snd.push_back(y_factors[j++]);
	return ret;
}

pair<ll, ll> reduce_fraction(ll x, ll y, const vll &prime_list) {
	pair<ll, ll> ret = { 1, 1 };
	vector<Pll> x_factors = prime_factorize(x, prime_list);
	vector<Pll> y_factors = prime_factorize(y, prime_list);
	pair<vector<Pll>, vector<Pll>> factors = reduce_common_factors(x_factors, y_factors);
	Loop(i, factors.fst.size()) ret.fst *= powll(factors.fst[i].fst, factors.fst[i].snd);
	Loop(i, factors.snd.size()) ret.snd *= powll(factors.snd[i].fst, factors.snd[i].snd);
	return ret;
}