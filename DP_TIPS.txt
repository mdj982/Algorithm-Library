dp[i][j]
- 基本的にはiまでしか使わずにjの場合を計算…
- 疑わしい値: dp[i-1][j], dp[i-1][j-v[i][j]], dp[i][j-v[i][j]]
- max? min? +? or? and?
- 似たこと2回やったりする

空間的節約法?
- 直前の行しか影響しない⇒2行だけ持つ
- 一定規則の列しか影響しない⇒数個の列だけ持つ
- iループ目で使うデータは実はlogj個?

時間的節約法?
- 三重ループ⇒実は展開可能?漸化式の工夫
- iループ目で使うデータは実はlogj個?
- O(~)の中身が1e9ぐらいになりそうなときで、データがbool型の時はbitset<>を疑う(計算量1/64)

ミスした時
- 基本的にはdp遷移のミスを疑う（dp以外でライブラリを用いているときはなおさら）
＜ミスのパターン＞
 - min, max などのカバー不足、特にコーナーケース付近
 - runtime error の場合は index のミス

個数制限partitionがしたい時
- 普通はDPだが…
- 特殊な場合その1：
-- 平方数 1^2, ..., K^2 と X が与えられたとき、
-- N >= (X / K^2) + log(K) + 1 であれば、
-- 全ての X 以下の整数 x に関して
-- これらの平方数のうちN個以下を用いて総和が x とする方法がある。時間計算量もやろうと思えばO(log(K))。
-- 特に X / K^2 が一桁程度であれば N = 20 程度。
- 特殊な場合その2：
-- 1e3までの素数の間隔の最大値は25未満。
-- 1e6までの素数の間隔の最大値は125未満。
-- 1e8までの素数の間隔の最大値は250未満。